//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import {catchError as _observableCatch, mergeMap as _observableMergeMap} from 'rxjs/operators';
import {Observable, of as _observableOf, throwError as _observableThrow} from 'rxjs';
import {Inject, Injectable, InjectionToken, Optional} from '@angular/core';
import {HttpClient, HttpHeaders, HttpResponse, HttpResponseBase} from '@angular/common/http';

export module FileServerApi {
  export const API_BASE_URL = new InjectionToken('API_BASE_URL');

  @Injectable({
    providedIn: 'root'
  })
  export class FileServerClient {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
    private http: HttpClient;
    private baseUrl: string;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param id ID der Classification
     * @return OK
     */
    classificationGET(id: number): Observable<void> {
      let url_ = this.baseUrl + "/api/classification?";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined and cannot be null.");
      else
        url_ += "id=" + encodeURIComponent("" + id) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processClassificationGET(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processClassificationGET(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    classificationPOST(body: ClassificationDto): Observable<void> {
      let url_ = this.baseUrl + "/api/classification";
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processClassificationPOST(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processClassificationPOST(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    classificationPUT(body: ClassificationDto): Observable<void> {
      let url_ = this.baseUrl + "/api/classification";
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processClassificationPUT(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processClassificationPUT(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @param id ID der Classification
     * @return OK
     */
    classificationDELETE(id: number): Observable<void> {
      let url_ = this.baseUrl + "/api/classification?";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined and cannot be null.");
      else
        url_ += "id=" + encodeURIComponent("" + id) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processClassificationDELETE(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processClassificationDELETE(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    all(): Observable<void> {
      let url_ = this.baseUrl + "/api/classification/all";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processAll(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processAll(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @param isActive (optional) Filter für aktive Dokumente
     * @param isDeleted (optional) Filter für gelöschte Dokumente
     * @param version (optional) Filter für Version der Dokumente
     * @return OK
     */
    all2(isActive: boolean | undefined, isDeleted: boolean | undefined, version: number | undefined): Observable<void> {
      let url_ = this.baseUrl + "/api/document/all?";
      if (isActive === null)
        throw new Error("The parameter 'isActive' cannot be null.");
      else if (isActive !== undefined)
        url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
      if (isDeleted === null)
        throw new Error("The parameter 'isDeleted' cannot be null.");
      else if (isDeleted !== undefined)
        url_ += "isDeleted=" + encodeURIComponent("" + isDeleted) + "&";
      if (version === null)
        throw new Error("The parameter 'version' cannot be null.");
      else if (version !== undefined)
        url_ += "version=" + encodeURIComponent("" + version) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processAll2(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processAll2(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @param id ID des Dokuments
     * @param isActive (optional) Filter für aktive Dokumente
     * @param isDeleted (optional) Filter für gelöschte Dokumente
     * @param version (optional) Filter für Version des Dokuments
     * @return OK
     */
    documentGET(id: number, isActive: boolean | undefined, isDeleted: boolean | undefined, version: number | undefined): Observable<void> {
      let url_ = this.baseUrl + "/api/document?";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined and cannot be null.");
      else
        url_ += "id=" + encodeURIComponent("" + id) + "&";
      if (isActive === null)
        throw new Error("The parameter 'isActive' cannot be null.");
      else if (isActive !== undefined)
        url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
      if (isDeleted === null)
        throw new Error("The parameter 'isDeleted' cannot be null.");
      else if (isDeleted !== undefined)
        url_ += "isDeleted=" + encodeURIComponent("" + isDeleted) + "&";
      if (version === null)
        throw new Error("The parameter 'version' cannot be null.");
      else if (version !== undefined)
        url_ += "version=" + encodeURIComponent("" + version) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processDocumentGET(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDocumentGET(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @param classificationId (optional)
     * @param guid (optional)
     * @param originalName (optional)
     * @param mediaType (optional)
     * @param createdDate (optional)
     * @param updatedDate (optional)
     * @param createdBy (optional)
     * @param language (optional)
     * @param version (optional)
     * @param metaData (optional)
     * @param pageNumbers (optional)
     * @param fileData (optional)
     * @return OK
     */
    documentPOST(classificationId: number | undefined, guid: string | null | undefined, originalName: string | null | undefined, mediaType: MediaType | undefined,
                 createdDate: Date | undefined, updatedDate: Date | undefined, createdBy: string | null | undefined, language: string | null | undefined, version: number | null | undefined,
                 metaData: string | null | undefined, pageNumbers: number[] | null | undefined, fileData: any[] | null | undefined): Observable<void> {
      let url_ = this.baseUrl + "/api/document";
      url_ = url_.replace(/[?&]$/, "");

      if(this.baseUrl.length === 0)
      {
        // url_ = "https://app-test.rehaneo.synios.local/rehaportal/api/document"; //mit Token
        url_ = "http://192.168.10.145:5210/api/document";
      }
console.log('url: ', url_);
      const content_ = new FormData();
      if (classificationId === null || classificationId === undefined)
        throw new Error("The parameter 'classificationId' cannot be null.");
      else
        content_.append("classificationId", classificationId.toString());
      if (guid !== null && guid !== undefined)
        content_.append("guid", guid.toString());
      if (originalName !== null && originalName !== undefined)
        content_.append("originalName", originalName.toString());
      if (mediaType === null || mediaType === undefined)
        throw new Error("The parameter 'mediaType' cannot be null.");
      else
        content_.append("mediaType", mediaType.toString());
      if (createdDate === null || createdDate === undefined)
        throw new Error("The parameter 'createdDate' cannot be null.");
      else
        content_.append("createdDate", createdDate.toJSON());
      if (updatedDate === null || updatedDate === undefined)
        throw new Error("The parameter 'updatedDate' cannot be null.");
      else
        content_.append("updatedDate", updatedDate.toJSON());
      if (createdBy !== null && createdBy !== undefined)
        content_.append("createdBy", createdBy.toString());
      if (language !== null && language !== undefined)
        content_.append("language", language.toString());
      if (version !== null && version !== undefined)
        content_.append("version", version.toString());
      if (metaData !== null && metaData !== undefined)
        content_.append("metaData", metaData.toString());
      if (pageNumbers !== null && pageNumbers !== undefined)
        pageNumbers.forEach(item_ => content_.append("pageNumbers", item_.toString()));
      if (fileData !== null && fileData !== undefined)
        fileData.forEach(item_ => content_.append("fileData", item_.data, item_.fileName ? item_.fileName : "fileData"));

      let options_: any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processDocumentPOST(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDocumentPOST(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    documentPUT(body: DocumentDto): Observable<void> {
      let url_ = this.baseUrl + "/api/document";
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processDocumentPUT(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDocumentPUT(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    documentDELETE(id: number): Observable<void> {
      let url_ = this.baseUrl + "/api/document?";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined and cannot be null.");
      else
        url_ += "id=" + encodeURIComponent("" + id) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processDocumentDELETE(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDocumentDELETE(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @param id ID des DocumentTypes
     * @return OK
     */
    documentTypeGET(id: number): Observable<void> {
      let url_ = this.baseUrl + "/api/documentType?";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined and cannot be null.");
      else
        url_ += "id=" + encodeURIComponent("" + id) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processDocumentTypeGET(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDocumentTypeGET(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    documentTypePOST(body: DocumentTypeDto): Observable<void> {
      let url_ = this.baseUrl + "/api/documentType";
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processDocumentTypePOST(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDocumentTypePOST(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    documentTypePUT(body: DocumentTypeDto): Observable<void> {
      let url_ = this.baseUrl + "/api/documentType";
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processDocumentTypePUT(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDocumentTypePUT(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    documentTypeDELETE(id: number): Observable<void> {
      let url_ = this.baseUrl + "/api/documentType?";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined and cannot be null.");
      else
        url_ += "id=" + encodeURIComponent("" + id) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processDocumentTypeDELETE(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDocumentTypeDELETE(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    all3(): Observable<void> {
      let url_ = this.baseUrl + "/api/documentType/all";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processAll3(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processAll3(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @param id ID des Dokuments
     * @param position Filter für die Position des Dokuments
     * @param isActive (optional) Filter für aktive Dokumente
     * @param isDeleted (optional) Filter für gelöschte Dokumente
     * @param version (optional) Filter für Version des Dokuments
     * @return OK
     */
    id(id: number, position: number, isActive: boolean | undefined, isDeleted: boolean | undefined, version: number | undefined): Observable<void> {
      let url_ = this.baseUrl + "/api/file/id?";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined and cannot be null.");
      else
        url_ += "id=" + encodeURIComponent("" + id) + "&";
      if (position === undefined || position === null)
        throw new Error("The parameter 'position' must be defined and cannot be null.");
      else
        url_ += "position=" + encodeURIComponent("" + position) + "&";
      if (isActive === null)
        throw new Error("The parameter 'isActive' cannot be null.");
      else if (isActive !== undefined)
        url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
      if (isDeleted === null)
        throw new Error("The parameter 'isDeleted' cannot be null.");
      else if (isDeleted !== undefined)
        url_ += "isDeleted=" + encodeURIComponent("" + isDeleted) + "&";
      if (version === null)
        throw new Error("The parameter 'version' cannot be null.");
      else if (version !== undefined)
        url_ += "version=" + encodeURIComponent("" + version) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processId(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processId(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @param customId customId des Dokuments
     * @param position Filter für die Position des Dokuments
     * @param isActive (optional) Filter für aktive Dokumente
     * @param isDeleted (optional) Filter für gelöschte Dokumente
     * @param version (optional) Filter für Version des Dokuments
     * @return OK
     */
    customid(customId: string, position: number, isActive: boolean | undefined, isDeleted: boolean | undefined, version: number | undefined): Observable<void> {
      let url_ = this.baseUrl + "/api/file/customid?";
      if (customId === undefined || customId === null)
        throw new Error("The parameter 'customId' must be defined and cannot be null.");
      else
        url_ += "customId=" + encodeURIComponent("" + customId) + "&";
      if (position === undefined || position === null)
        throw new Error("The parameter 'position' must be defined and cannot be null.");
      else
        url_ += "position=" + encodeURIComponent("" + position) + "&";
      if (isActive === null)
        throw new Error("The parameter 'isActive' cannot be null.");
      else if (isActive !== undefined)
        url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
      if (isDeleted === null)
        throw new Error("The parameter 'isDeleted' cannot be null.");
      else if (isDeleted !== undefined)
        url_ += "isDeleted=" + encodeURIComponent("" + isDeleted) + "&";
      if (version === null)
        throw new Error("The parameter 'version' cannot be null.");
      else if (version !== undefined)
        url_ += "version=" + encodeURIComponent("" + version) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processCustomid(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCustomid(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @param id ID des Dokuments
     * @param startSecond (optional) Startposition in Sekunden
     * @param sessionId (optional) Eindeutige Session-ID
     * @return OK
     */
    documentGET2(id: number, startSecond: number | undefined, sessionId: string | undefined): Observable<void> {
      let url_ = this.baseUrl + "/api/file/stream/document/{id}?";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id));
      if (startSecond === null)
        throw new Error("The parameter 'startSecond' cannot be null.");
      else if (startSecond !== undefined)
        url_ += "startSecond=" + encodeURIComponent("" + startSecond) + "&";
      if (sessionId === null)
        throw new Error("The parameter 'sessionId' cannot be null.");
      else if (sessionId !== undefined)
        url_ += "sessionId=" + encodeURIComponent("" + sessionId) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processDocumentGET2(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDocumentGET2(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @param customId CustomId des Dokuments
     * @param startSecond (optional) Startposition in Sekunden
     * @param sessionId (optional) Eindeutige Session-ID
     * @return OK
     */
    custom(customId: string, startSecond: number | undefined, sessionId: string | undefined): Observable<void> {
      let url_ = this.baseUrl + "/api/file/stream/custom/{customId}?";
      if (customId === undefined || customId === null)
        throw new Error("The parameter 'customId' must be defined.");
      url_ = url_.replace("{customId}", encodeURIComponent("" + customId));
      if (startSecond === null)
        throw new Error("The parameter 'startSecond' cannot be null.");
      else if (startSecond !== undefined)
        url_ += "startSecond=" + encodeURIComponent("" + startSecond) + "&";
      if (sessionId === null)
        throw new Error("The parameter 'sessionId' cannot be null.");
      else if (sessionId !== undefined)
        url_ += "sessionId=" + encodeURIComponent("" + sessionId) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processCustom(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCustom(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    pause(sessionId: string): Observable<void> {
      let url_ = this.baseUrl + "/api/file/stream/{sessionId}/pause";
      if (sessionId === undefined || sessionId === null)
        throw new Error("The parameter 'sessionId' must be defined.");
      url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({})
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processPause(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processPause(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    resume(sessionId: string): Observable<void> {
      let url_ = this.baseUrl + "/api/file/stream/{sessionId}/resume";
      if (sessionId === undefined || sessionId === null)
        throw new Error("The parameter 'sessionId' must be defined.");
      url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({})
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processResume(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processResume(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    stream(sessionId: string): Observable<void> {
      let url_ = this.baseUrl + "/api/file/stream/{sessionId}";
      if (sessionId === undefined || sessionId === null)
        throw new Error("The parameter 'sessionId' must be defined.");
      url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({})
      };

      return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processStream(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processStream(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @param id ID des Folders
     * @return OK
     */
    folderGET(id: number): Observable<void> {
      let url_ = this.baseUrl + "/api/folder?";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined and cannot be null.");
      else
        url_ += "id=" + encodeURIComponent("" + id) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processFolderGET(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processFolderGET(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    folderPOST(body: FolderDto): Observable<void> {
      let url_ = this.baseUrl + "/api/folder";
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processFolderPOST(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processFolderPOST(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    folderPUT(body: FolderDto): Observable<void> {
      let url_ = this.baseUrl + "/api/folder";
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processFolderPUT(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processFolderPUT(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    folderDELETE(id: number): Observable<void> {
      let url_ = this.baseUrl + "/api/folder?";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined and cannot be null.");
      else
        url_ += "id=" + encodeURIComponent("" + id) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processFolderDELETE(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processFolderDELETE(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    active(): Observable<void> {
      let url_ = this.baseUrl + "/api/folder/active";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processActive(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processActive(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    all4(): Observable<void> {
      let url_ = this.baseUrl + "/api/folder/all";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processAll4(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processAll4(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @param id ID des Mediums
     * @return OK
     */
    mediumGET(id: number): Observable<void> {
      let url_ = this.baseUrl + "/api/medium?";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined and cannot be null.");
      else
        url_ += "id=" + encodeURIComponent("" + id) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processMediumGET(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processMediumGET(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    mediumPOST(body: MediumDto): Observable<void> {
      let url_ = this.baseUrl + "/api/medium";
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processMediumPOST(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processMediumPOST(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    mediumPUT(body: MediumDto): Observable<void> {
      let url_ = this.baseUrl + "/api/medium";
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processMediumPUT(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processMediumPUT(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    mediumDELETE(id: number): Observable<void> {
      let url_ = this.baseUrl + "/api/medium?";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined and cannot be null.");
      else
        url_ += "id=" + encodeURIComponent("" + id) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processMediumDELETE(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processMediumDELETE(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    all5(): Observable<void> {
      let url_ = this.baseUrl + "/api/medium/all";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processAll5(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processAll5(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    active2(): Observable<void> {
      let url_ = this.baseUrl + "/api/medium/active";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processActive2(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processActive2(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @param id ID des Pages
     * @return OK
     */
    pageGET(id: number): Observable<void> {
      let url_ = this.baseUrl + "/api/page?";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined and cannot be null.");
      else
        url_ += "id=" + encodeURIComponent("" + id) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processPageGET(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processPageGET(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    pagePOST(body: PageDto): Observable<void> {
      let url_ = this.baseUrl + "/api/page";
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processPagePOST(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processPagePOST(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    pagePUT(body: PageDto): Observable<void> {
      let url_ = this.baseUrl + "/api/page";
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processPagePUT(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processPagePUT(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    pageDELETE(id: number): Observable<void> {
      let url_ = this.baseUrl + "/api/page?";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined and cannot be null.");
      else
        url_ += "id=" + encodeURIComponent("" + id) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processPageDELETE(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processPageDELETE(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @param documentId ID des Dokuments
     * @param isActive (optional) Filter für aktive Dokumente
     * @param isDeleted (optional) Filter für gelöschte Dokumente
     * @param version (optional) Filter für Version des Dokuments
     * @param position (optional) Filter für die Position des Dokuments
     * @return OK
     */
    documentId(documentId: number, isActive: boolean | undefined, isDeleted: boolean | undefined, version: number | undefined, position: number | undefined): Observable<void> {
      let url_ = this.baseUrl + "/api/page/documentId?";
      if (documentId === undefined || documentId === null)
        throw new Error("The parameter 'documentId' must be defined and cannot be null.");
      else
        url_ += "DocumentId=" + encodeURIComponent("" + documentId) + "&";
      if (isActive === null)
        throw new Error("The parameter 'isActive' cannot be null.");
      else if (isActive !== undefined)
        url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
      if (isDeleted === null)
        throw new Error("The parameter 'isDeleted' cannot be null.");
      else if (isDeleted !== undefined)
        url_ += "isDeleted=" + encodeURIComponent("" + isDeleted) + "&";
      if (version === null)
        throw new Error("The parameter 'version' cannot be null.");
      else if (version !== undefined)
        url_ += "version=" + encodeURIComponent("" + version) + "&";
      if (position === null)
        throw new Error("The parameter 'position' cannot be null.");
      else if (position !== undefined)
        url_ += "position=" + encodeURIComponent("" + position) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processDocumentId(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDocumentId(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @param customId CustomId des Dokuments
     * @param isActive (optional) Filter für aktive Dokumente
     * @param isDeleted (optional) Filter für gelöschte Dokumente
     * @param version (optional) Filter für die Version des Dokuments
     * @param position (optional) Filter für die Position des Dokuments
     * @return OK
     */
    customId(customId: string, isActive: boolean | undefined, isDeleted: boolean | undefined, version: number | undefined, position: number | undefined): Observable<void> {
      let url_ = this.baseUrl + "/api/page/customId?";
      if (customId === undefined || customId === null)
        throw new Error("The parameter 'customId' must be defined and cannot be null.");
      else
        url_ += "CustomId=" + encodeURIComponent("" + customId) + "&";
      if (isActive === null)
        throw new Error("The parameter 'isActive' cannot be null.");
      else if (isActive !== undefined)
        url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
      if (isDeleted === null)
        throw new Error("The parameter 'isDeleted' cannot be null.");
      else if (isDeleted !== undefined)
        url_ += "isDeleted=" + encodeURIComponent("" + isDeleted) + "&";
      if (version === null)
        throw new Error("The parameter 'version' cannot be null.");
      else if (version !== undefined)
        url_ += "version=" + encodeURIComponent("" + version) + "&";
      if (position === null)
        throw new Error("The parameter 'position' cannot be null.");
      else if (position !== undefined)
        url_ += "position=" + encodeURIComponent("" + position) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processCustomId(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCustomId(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @param isActive (optional)
     * @param isDeleted (optional)
     * @param version (optional)
     * @return OK
     */
    all6(isActive: boolean | undefined, isDeleted: boolean | undefined, version: number | undefined): Observable<void> {
      let url_ = this.baseUrl + "/api/page/all?";
      if (isActive === null)
        throw new Error("The parameter 'isActive' cannot be null.");
      else if (isActive !== undefined)
        url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
      if (isDeleted === null)
        throw new Error("The parameter 'isDeleted' cannot be null.");
      else if (isDeleted !== undefined)
        url_ += "isDeleted=" + encodeURIComponent("" + isDeleted) + "&";
      if (version === null)
        throw new Error("The parameter 'version' cannot be null.");
      else if (version !== undefined)
        url_ += "version=" + encodeURIComponent("" + version) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processAll6(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processAll6(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @param id ID des Settings
     * @return OK
     */
    settingGET(id: number): Observable<void> {
      let url_ = this.baseUrl + "/api/setting?";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined and cannot be null.");
      else
        url_ += "id=" + encodeURIComponent("" + id) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processSettingGET(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processSettingGET(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    settingPOST(body: SettingDto): Observable<void> {
      let url_ = this.baseUrl + "/api/setting";
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processSettingPOST(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processSettingPOST(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    settingPUT(body: SettingDto): Observable<void> {
      let url_ = this.baseUrl + "/api/setting";
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processSettingPUT(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processSettingPUT(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    settingDELETE(id: number): Observable<void> {
      let url_ = this.baseUrl + "/api/setting?";
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined and cannot be null.");
      else
        url_ += "id=" + encodeURIComponent("" + id) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processSettingDELETE(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processSettingDELETE(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    byName(name: string): Observable<void> {
      let url_ = this.baseUrl + "/api/setting/ByName?";
      if (name === undefined || name === null)
        throw new Error("The parameter 'name' must be defined and cannot be null.");
      else
        url_ += "name=" + encodeURIComponent("" + name) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processByName(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processByName(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    all7(): Observable<void> {
      let url_ = this.baseUrl + "/api/setting/all";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processAll7(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processAll7(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    create(): Observable<void> {
      let url_ = this.baseUrl + "/api/database/create";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processCreate(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCreate(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    initialize(): Observable<void> {
      let url_ = this.baseUrl + "/api/database/initialize";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processInitialize(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processInitialize(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    /**
     * @return OK
     */
    reset(): Observable<void> {
      let url_ = this.baseUrl + "/api/database/reset";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processReset(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processReset(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<void>;
          }
        } else
          return _observableThrow(response_) as any as Observable<void>;
      }));
    }

    protected processClassificationGET(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processClassificationPOST(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 201) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result201: any = null;
          let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result201 = IClassification.fromJS(resultData201);
          return throwException("Created", status, _responseText, _headers, result201);
        }));
      } else if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = resultData400 !== undefined ? resultData400 : <any>null;

          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = resultData409 !== undefined ? resultData409 : <any>null;

          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processClassificationPUT(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result204: any = null;
          let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result204 = resultData204 !== undefined ? resultData204 : <any>null;

          return throwException("No Content", status, _responseText, _headers, result204);
        }));
      } else if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = resultData400 !== undefined ? resultData400 : <any>null;

          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processClassificationDELETE(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result204: any = null;
          let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result204 = resultData204 !== undefined ? resultData204 : <any>null;

          return throwException("No Content", status, _responseText, _headers, result204);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = resultData401 !== undefined ? resultData401 : <any>null;

          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processAll(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processAll2(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processDocumentGET(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processDocumentPOST(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 201) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result201: any = null;
          let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result201 = IDocument.fromJS(resultData201);
          return throwException("Created", status, _responseText, _headers, result201);
        }));
      } else if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = resultData400 !== undefined ? resultData400 : <any>null;

          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = resultData409 !== undefined ? resultData409 : <any>null;

          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processDocumentPUT(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result204: any = null;
          let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result204 = resultData204 !== undefined ? resultData204 : <any>null;

          return throwException("No Content", status, _responseText, _headers, result204);
        }));
      } else if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = resultData400 !== undefined ? resultData400 : <any>null;

          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processDocumentDELETE(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result204: any = null;
          let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result204 = resultData204 !== undefined ? resultData204 : <any>null;

          return throwException("No Content", status, _responseText, _headers, result204);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = resultData401 !== undefined ? resultData401 : <any>null;

          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processDocumentTypeGET(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processDocumentTypePOST(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 201) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result201: any = null;
          let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result201 = IDocumentType.fromJS(resultData201);
          return throwException("Created", status, _responseText, _headers, result201);
        }));
      } else if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = resultData400 !== undefined ? resultData400 : <any>null;

          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = resultData409 !== undefined ? resultData409 : <any>null;

          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processDocumentTypePUT(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result204: any = null;
          let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result204 = resultData204 !== undefined ? resultData204 : <any>null;

          return throwException("No Content", status, _responseText, _headers, result204);
        }));
      } else if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = resultData400 !== undefined ? resultData400 : <any>null;

          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processDocumentTypeDELETE(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result204: any = null;
          let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result204 = resultData204 !== undefined ? resultData204 : <any>null;

          return throwException("No Content", status, _responseText, _headers, result204);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = resultData401 !== undefined ? resultData401 : <any>null;

          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processAll3(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processId(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processCustomid(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processDocumentGET2(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processCustom(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processPause(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processResume(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processStream(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processFolderGET(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processFolderPOST(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 201) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result201: any = null;
          let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result201 = IFolder.fromJS(resultData201);
          return throwException("Created", status, _responseText, _headers, result201);
        }));
      } else if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = resultData400 !== undefined ? resultData400 : <any>null;

          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = resultData409 !== undefined ? resultData409 : <any>null;

          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processFolderPUT(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result204: any = null;
          let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result204 = resultData204 !== undefined ? resultData204 : <any>null;

          return throwException("No Content", status, _responseText, _headers, result204);
        }));
      } else if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = resultData400 !== undefined ? resultData400 : <any>null;

          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processFolderDELETE(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result204: any = null;
          let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result204 = resultData204 !== undefined ? resultData204 : <any>null;

          return throwException("No Content", status, _responseText, _headers, result204);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = resultData401 !== undefined ? resultData401 : <any>null;

          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processActive(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processAll4(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processMediumGET(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processMediumPOST(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 201) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result201: any = null;
          let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result201 = IMedium.fromJS(resultData201);
          return throwException("Created", status, _responseText, _headers, result201);
        }));
      } else if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = resultData400 !== undefined ? resultData400 : <any>null;

          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = resultData409 !== undefined ? resultData409 : <any>null;

          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processMediumPUT(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result204: any = null;
          let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result204 = resultData204 !== undefined ? resultData204 : <any>null;

          return throwException("No Content", status, _responseText, _headers, result204);
        }));
      } else if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = resultData400 !== undefined ? resultData400 : <any>null;

          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processMediumDELETE(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result204: any = null;
          let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result204 = resultData204 !== undefined ? resultData204 : <any>null;

          return throwException("No Content", status, _responseText, _headers, result204);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = resultData401 !== undefined ? resultData401 : <any>null;

          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processAll5(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processActive2(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processPageGET(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processPagePOST(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 201) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result201: any = null;
          let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result201 = IPage.fromJS(resultData201);
          return throwException("Created", status, _responseText, _headers, result201);
        }));
      } else if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = resultData400 !== undefined ? resultData400 : <any>null;

          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = resultData409 !== undefined ? resultData409 : <any>null;

          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processPagePUT(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result204: any = null;
          let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result204 = resultData204 !== undefined ? resultData204 : <any>null;

          return throwException("No Content", status, _responseText, _headers, result204);
        }));
      } else if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = resultData400 !== undefined ? resultData400 : <any>null;

          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processPageDELETE(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result204: any = null;
          let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result204 = resultData204 !== undefined ? resultData204 : <any>null;

          return throwException("No Content", status, _responseText, _headers, result204);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = resultData401 !== undefined ? resultData401 : <any>null;

          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processDocumentId(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processCustomId(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processAll6(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processSettingGET(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processSettingPOST(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 201) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result201: any = null;
          let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result201 = ISetting.fromJS(resultData201);
          return throwException("Created", status, _responseText, _headers, result201);
        }));
      } else if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = resultData400 !== undefined ? resultData400 : <any>null;

          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = resultData409 !== undefined ? resultData409 : <any>null;

          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processSettingPUT(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result204: any = null;
          let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result204 = resultData204 !== undefined ? resultData204 : <any>null;

          return throwException("No Content", status, _responseText, _headers, result204);
        }));
      } else if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = resultData400 !== undefined ? resultData400 : <any>null;

          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processSettingDELETE(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result204: any = null;
          let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result204 = resultData204 !== undefined ? resultData204 : <any>null;

          return throwException("No Content", status, _responseText, _headers, result204);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = resultData401 !== undefined ? resultData401 : <any>null;

          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processByName(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processAll7(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processInitialize(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = resultData404 !== undefined ? resultData404 : <any>null;

          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }

    protected processReset(response: HttpResponseBase): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return _observableOf<void>(null as any);
        }));
      } else if (status === 500) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result500: any = null;
          let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result500 = resultData500 !== undefined ? resultData500 : <any>null;

          return throwException("Internal Server Error", status, _responseText, _headers, result500);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf<void>(null as any);
    }
  }

  export class ClassificationDto implements IClassificationDto {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;

    constructor(data?: IClassificationDto) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): ClassificationDto {
      data = typeof data === 'object' ? data : {};
      let result = new ClassificationDto();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data["id"];
        this.name = _data["name"];
        this.code = _data["code"];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["id"] = this.id;
      data["name"] = this.name;
      data["code"] = this.code;
      return data;
    }
  }

  export interface IClassificationDto {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;
  }

  export class DocumentDto implements IDocumentDto {
    id?: number;
    documentTypeId?: number;
    classificationId?: number;
    mediumId?: number;
    customId?: string | undefined;
    originalName?: string | undefined;
    cdName?: string | undefined;
    filePath?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    createdBy?: string | undefined;
    isActive?: boolean;
    isDeleted?: boolean;
    language?: string | undefined;
    version?: number | undefined;
    metaData?: string | undefined;
    pages?: IPage[] | undefined;

    constructor(data?: IDocumentDto) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): DocumentDto {
      data = typeof data === 'object' ? data : {};
      let result = new DocumentDto();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data["id"];
        this.documentTypeId = _data["documentTypeId"];
        this.classificationId = _data["classificationId"];
        this.mediumId = _data["mediumId"];
        this.customId = _data["customId"];
        this.originalName = _data["originalName"];
        this.cdName = _data["cdName"];
        this.filePath = _data["filePath"];
        this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
        this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
        this.createdBy = _data["createdBy"];
        this.isActive = _data["isActive"];
        this.isDeleted = _data["isDeleted"];
        this.language = _data["language"];
        this.version = _data["version"];
        this.metaData = _data["metaData"];
        if (Array.isArray(_data["pages"])) {
          this.pages = [] as any;
          for (let item of _data["pages"])
            this.pages!.push(IPage.fromJS(item));
        }
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["id"] = this.id;
      data["documentTypeId"] = this.documentTypeId;
      data["classificationId"] = this.classificationId;
      data["mediumId"] = this.mediumId;
      data["customId"] = this.customId;
      data["originalName"] = this.originalName;
      data["cdName"] = this.cdName;
      data["filePath"] = this.filePath;
      data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
      data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
      data["createdBy"] = this.createdBy;
      data["isActive"] = this.isActive;
      data["isDeleted"] = this.isDeleted;
      data["language"] = this.language;
      data["version"] = this.version;
      data["metaData"] = this.metaData;
      if (Array.isArray(this.pages)) {
        data["pages"] = [];
        for (let item of this.pages)
          data["pages"].push(item ? item.toJSON() : <any>undefined);
      }
      return data;
    }
  }

  export interface IDocumentDto {
    id?: number;
    documentTypeId?: number;
    classificationId?: number;
    mediumId?: number;
    customId?: string | undefined;
    originalName?: string | undefined;
    cdName?: string | undefined;
    filePath?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    createdBy?: string | undefined;
    isActive?: boolean;
    isDeleted?: boolean;
    language?: string | undefined;
    version?: number | undefined;
    metaData?: string | undefined;
    pages?: IPage[] | undefined;
  }

  export class DocumentTypeDto implements IDocumentTypeDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: IDocumentTypeDto) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): DocumentTypeDto {
      data = typeof data === 'object' ? data : {};
      let result = new DocumentTypeDto();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data["id"];
        this.name = _data["name"];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["id"] = this.id;
      data["name"] = this.name;
      return data;
    }
  }

  export interface IDocumentTypeDto {
    id?: number;
    name?: string | undefined;
  }

  export class FolderDto implements IFolderDto {
    id?: number;
    path?: string | undefined;
    isActive?: boolean;

    constructor(data?: IFolderDto) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): FolderDto {
      data = typeof data === 'object' ? data : {};
      let result = new FolderDto();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data["id"];
        this.path = _data["path"];
        this.isActive = _data["isActive"];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["id"] = this.id;
      data["path"] = this.path;
      data["isActive"] = this.isActive;
      return data;
    }
  }

  export interface IFolderDto {
    id?: number;
    path?: string | undefined;
    isActive?: boolean;
  }

  export class IClassification implements IIClassification {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;

    constructor(data?: IIClassification) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): IClassification {
      data = typeof data === 'object' ? data : {};
      let result = new IClassification();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data["id"];
        this.name = _data["name"];
        this.code = _data["code"];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["id"] = this.id;
      data["name"] = this.name;
      data["code"] = this.code;
      return data;
    }
  }

  export interface IIClassification {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;
  }

  export class IDocument implements IIDocument {
    id?: number;
    documentTypeId?: number;
    classificationId?: number;
    mediumId?: number;
    customId?: string | undefined;
    originalName?: string | undefined;
    cdName?: string | undefined;
    filePath?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    createdBy?: string | undefined;
    isActive?: boolean;
    isDeleted?: boolean;
    language?: string | undefined;
    version?: number | undefined;
    metaData?: string | undefined;
    pages?: IPage[] | undefined;

    constructor(data?: IIDocument) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): IDocument {
      data = typeof data === 'object' ? data : {};
      let result = new IDocument();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data["id"];
        this.documentTypeId = _data["documentTypeId"];
        this.classificationId = _data["classificationId"];
        this.mediumId = _data["mediumId"];
        this.customId = _data["customId"];
        this.originalName = _data["originalName"];
        this.cdName = _data["cdName"];
        this.filePath = _data["filePath"];
        this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
        this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
        this.createdBy = _data["createdBy"];
        this.isActive = _data["isActive"];
        this.isDeleted = _data["isDeleted"];
        this.language = _data["language"];
        this.version = _data["version"];
        this.metaData = _data["metaData"];
        if (Array.isArray(_data["pages"])) {
          this.pages = [] as any;
          for (let item of _data["pages"])
            this.pages!.push(IPage.fromJS(item));
        }
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["id"] = this.id;
      data["documentTypeId"] = this.documentTypeId;
      data["classificationId"] = this.classificationId;
      data["mediumId"] = this.mediumId;
      data["customId"] = this.customId;
      data["originalName"] = this.originalName;
      data["cdName"] = this.cdName;
      data["filePath"] = this.filePath;
      data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
      data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
      data["createdBy"] = this.createdBy;
      data["isActive"] = this.isActive;
      data["isDeleted"] = this.isDeleted;
      data["language"] = this.language;
      data["version"] = this.version;
      data["metaData"] = this.metaData;
      if (Array.isArray(this.pages)) {
        data["pages"] = [];
        for (let item of this.pages)
          data["pages"].push(item ? item.toJSON() : <any>undefined);
      }
      return data;
    }
  }

  export interface IIDocument {
    id?: number;
    documentTypeId?: number;
    classificationId?: number;
    mediumId?: number;
    customId?: string | undefined;
    originalName?: string | undefined;
    cdName?: string | undefined;
    filePath?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    createdBy?: string | undefined;
    isActive?: boolean;
    isDeleted?: boolean;
    language?: string | undefined;
    version?: number | undefined;
    metaData?: string | undefined;
    pages?: IPage[] | undefined;
  }

  export class IDocumentType implements IIDocumentType {
    id?: number;
    name?: string | undefined;

    constructor(data?: IIDocumentType) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): IDocumentType {
      data = typeof data === 'object' ? data : {};
      let result = new IDocumentType();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data["id"];
        this.name = _data["name"];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["id"] = this.id;
      data["name"] = this.name;
      return data;
    }
  }

  export interface IIDocumentType {
    id?: number;
    name?: string | undefined;
  }

  export class IFolder implements IIFolder {
    id?: number;
    path?: string | undefined;
    isActive?: boolean;

    constructor(data?: IIFolder) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): IFolder {
      data = typeof data === 'object' ? data : {};
      let result = new IFolder();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data["id"];
        this.path = _data["path"];
        this.isActive = _data["isActive"];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["id"] = this.id;
      data["path"] = this.path;
      data["isActive"] = this.isActive;
      return data;
    }
  }

  export interface IIFolder {
    id?: number;
    path?: string | undefined;
    isActive?: boolean;
  }

  export class IMedium implements IIMedium {
    id?: number;
    folderId?: number;
    cdNr?: string | undefined;
    isActive?: boolean;
    mediumPrefix?: string | undefined;
    creationTime?: Date;
    positionNr?: number;
    mediumSize?: number;
    currentSize?: number;

    constructor(data?: IIMedium) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): IMedium {
      data = typeof data === 'object' ? data : {};
      let result = new IMedium();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data["id"];
        this.folderId = _data["folderId"];
        this.cdNr = _data["cdNr"];
        this.isActive = _data["isActive"];
        this.mediumPrefix = _data["mediumPrefix"];
        this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        this.positionNr = _data["positionNr"];
        this.mediumSize = _data["mediumSize"];
        this.currentSize = _data["currentSize"];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["id"] = this.id;
      data["folderId"] = this.folderId;
      data["cdNr"] = this.cdNr;
      data["isActive"] = this.isActive;
      data["mediumPrefix"] = this.mediumPrefix;
      data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
      data["positionNr"] = this.positionNr;
      data["mediumSize"] = this.mediumSize;
      data["currentSize"] = this.currentSize;
      return data;
    }
  }

  export interface IIMedium {
    id?: number;
    folderId?: number;
    cdNr?: string | undefined;
    isActive?: boolean;
    mediumPrefix?: string | undefined;
    creationTime?: Date;
    positionNr?: number;
    mediumSize?: number;
    currentSize?: number;
  }

  export class IPage implements IIPage {
    id?: number;
    documentId?: number;
    documentTypeId?: number;
    customId?: string | undefined;
    filePath?: string | undefined;
    fileName?: string | undefined;
    cdName?: string | undefined;
    target?: string | undefined;
    isActive?: boolean;
    isDeleted?: boolean;
    positionNr?: number;
    contentType?: string | undefined;

    constructor(data?: IIPage) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): IPage {
      data = typeof data === 'object' ? data : {};
      let result = new IPage();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data["id"];
        this.documentId = _data["documentId"];
        this.documentTypeId = _data["documentTypeId"];
        this.customId = _data["customId"];
        this.filePath = _data["filePath"];
        this.fileName = _data["fileName"];
        this.cdName = _data["cdName"];
        this.target = _data["target"];
        this.isActive = _data["isActive"];
        this.isDeleted = _data["isDeleted"];
        this.positionNr = _data["positionNr"];
        this.contentType = _data["contentType"];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["id"] = this.id;
      data["documentId"] = this.documentId;
      data["documentTypeId"] = this.documentTypeId;
      data["customId"] = this.customId;
      data["filePath"] = this.filePath;
      data["fileName"] = this.fileName;
      data["cdName"] = this.cdName;
      data["target"] = this.target;
      data["isActive"] = this.isActive;
      data["isDeleted"] = this.isDeleted;
      data["positionNr"] = this.positionNr;
      data["contentType"] = this.contentType;
      return data;
    }
  }

  export interface IIPage {
    id?: number;
    documentId?: number;
    documentTypeId?: number;
    customId?: string | undefined;
    filePath?: string | undefined;
    fileName?: string | undefined;
    cdName?: string | undefined;
    target?: string | undefined;
    isActive?: boolean;
    isDeleted?: boolean;
    positionNr?: number;
    contentType?: string | undefined;
  }

  export class ISetting implements IISetting {
    id?: number;
    name?: string | undefined;
    value?: string | undefined;
    valueType?: SettingValueType;
    description?: string | undefined;

    constructor(data?: IISetting) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): ISetting {
      data = typeof data === 'object' ? data : {};
      let result = new ISetting();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data["id"];
        this.name = _data["name"];
        this.value = _data["value"];
        this.valueType = _data["valueType"];
        this.description = _data["description"];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["id"] = this.id;
      data["name"] = this.name;
      data["value"] = this.value;
      data["valueType"] = this.valueType;
      data["description"] = this.description;
      return data;
    }
  }

  export interface IISetting {
    id?: number;
    name?: string | undefined;
    value?: string | undefined;
    valueType?: SettingValueType;
    description?: string | undefined;
  }

  /** Video = 1 - Document = 2 - Image = 3 - Audio = 4 - */
  export enum MediaType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
  }

  export class MediumDto implements IMediumDto {
    id?: number;
    folderId?: number;
    cdNr?: string | undefined;
    isActive?: boolean;
    mediumPrefix?: string | undefined;
    creationTime?: Date;
    positionNr?: number;
    mediumSize?: number;
    currentSize?: number;

    constructor(data?: IMediumDto) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): MediumDto {
      data = typeof data === 'object' ? data : {};
      let result = new MediumDto();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data["id"];
        this.folderId = _data["folderId"];
        this.cdNr = _data["cdNr"];
        this.isActive = _data["isActive"];
        this.mediumPrefix = _data["mediumPrefix"];
        this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        this.positionNr = _data["positionNr"];
        this.mediumSize = _data["mediumSize"];
        this.currentSize = _data["currentSize"];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["id"] = this.id;
      data["folderId"] = this.folderId;
      data["cdNr"] = this.cdNr;
      data["isActive"] = this.isActive;
      data["mediumPrefix"] = this.mediumPrefix;
      data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
      data["positionNr"] = this.positionNr;
      data["mediumSize"] = this.mediumSize;
      data["currentSize"] = this.currentSize;
      return data;
    }
  }

  export interface IMediumDto {
    id?: number;
    folderId?: number;
    cdNr?: string | undefined;
    isActive?: boolean;
    mediumPrefix?: string | undefined;
    creationTime?: Date;
    positionNr?: number;
    mediumSize?: number;
    currentSize?: number;
  }

  export class PageDto implements IPageDto {
    id?: number;
    documentId?: number;
    documentTypeId?: number;
    customId?: string | undefined;
    filePath?: string | undefined;
    isActive?: boolean;
    isDeleted?: boolean;
    positionNr?: number;
    fileName?: string | undefined;
    cdName?: string | undefined;
    target?: string | undefined;
    contentType?: string | undefined;

    constructor(data?: IPageDto) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): PageDto {
      data = typeof data === 'object' ? data : {};
      let result = new PageDto();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data["id"];
        this.documentId = _data["documentId"];
        this.documentTypeId = _data["documentTypeId"];
        this.customId = _data["customId"];
        this.filePath = _data["filePath"];
        this.isActive = _data["isActive"];
        this.isDeleted = _data["isDeleted"];
        this.positionNr = _data["positionNr"];
        this.fileName = _data["fileName"];
        this.cdName = _data["cdName"];
        this.target = _data["target"];
        this.contentType = _data["contentType"];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["id"] = this.id;
      data["documentId"] = this.documentId;
      data["documentTypeId"] = this.documentTypeId;
      data["customId"] = this.customId;
      data["filePath"] = this.filePath;
      data["isActive"] = this.isActive;
      data["isDeleted"] = this.isDeleted;
      data["positionNr"] = this.positionNr;
      data["fileName"] = this.fileName;
      data["cdName"] = this.cdName;
      data["target"] = this.target;
      data["contentType"] = this.contentType;
      return data;
    }
  }

  export interface IPageDto {
    id?: number;
    documentId?: number;
    documentTypeId?: number;
    customId?: string | undefined;
    filePath?: string | undefined;
    isActive?: boolean;
    isDeleted?: boolean;
    positionNr?: number;
    fileName?: string | undefined;
    cdName?: string | undefined;
    target?: string | undefined;
    contentType?: string | undefined;
  }

  export class SettingDto implements ISettingDto {
    id?: number;
    name?: string | undefined;
    value?: string | undefined;
    valueType?: SettingValueType;
    description?: string | undefined;

    constructor(data?: ISettingDto) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): SettingDto {
      data = typeof data === 'object' ? data : {};
      let result = new SettingDto();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data["id"];
        this.name = _data["name"];
        this.value = _data["value"];
        this.valueType = _data["valueType"];
        this.description = _data["description"];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["id"] = this.id;
      data["name"] = this.name;
      data["value"] = this.value;
      data["valueType"] = this.valueType;
      data["description"] = this.description;
      return data;
    }
  }

  export interface ISettingDto {
    id?: number;
    name?: string | undefined;
    value?: string | undefined;
    valueType?: SettingValueType;
    description?: string | undefined;
  }

  /** String = 1 - Textwert für Einstellungen Int = 2 - Ganzzahliger Wert für Einstellungen Bool = 3 - Boolescher Wert (wahr/falsch) für Einstellungen List = 4 - Listenwert für Einstellungen */
  export enum SettingValueType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
  }

  export class TransferDto implements ITransferDto {
    classificationId?: number;
    guid?: string | undefined;
    originalName?: string | undefined;
    mediaType?: MediaType;
    createdDate?: Date;
    updatedDate?: Date;
    createdBy?: string | undefined;
    language?: string | undefined;
    version?: number | undefined;
    metaData?: string | undefined;
    pageNumbers?: number[] | undefined;
    fileData?: string[] | undefined;

    constructor(data?: ITransferDto) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): TransferDto {
      data = typeof data === 'object' ? data : {};
      let result = new TransferDto();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.classificationId = _data["classificationId"];
        this.guid = _data["guid"];
        this.originalName = _data["originalName"];
        this.mediaType = _data["mediaType"];
        this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
        this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
        this.createdBy = _data["createdBy"];
        this.language = _data["language"];
        this.version = _data["version"];
        this.metaData = _data["metaData"];
        if (Array.isArray(_data["pageNumbers"])) {
          this.pageNumbers = [] as any;
          for (let item of _data["pageNumbers"])
            this.pageNumbers!.push(item);
        }
        if (Array.isArray(_data["fileData"])) {
          this.fileData = [] as any;
          for (let item of _data["fileData"])
            this.fileData!.push(item);
        }
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["classificationId"] = this.classificationId;
      data["guid"] = this.guid;
      data["originalName"] = this.originalName;
      data["mediaType"] = this.mediaType;
      data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
      data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
      data["createdBy"] = this.createdBy;
      data["language"] = this.language;
      data["version"] = this.version;
      data["metaData"] = this.metaData;
      if (Array.isArray(this.pageNumbers)) {
        data["pageNumbers"] = [];
        for (let item of this.pageNumbers)
          data["pageNumbers"].push(item);
      }
      if (Array.isArray(this.fileData)) {
        data["fileData"] = [];
        for (let item of this.fileData)
          data["fileData"].push(item);
      }
      return data;
    }
  }

  export interface ITransferDto {
    classificationId?: number;
    guid?: string | undefined;
    originalName?: string | undefined;
    mediaType?: MediaType;
    createdDate?: Date;
    updatedDate?: Date;
    createdBy?: string | undefined;
    language?: string | undefined;
    version?: number | undefined;
    metaData?: string | undefined;
    pageNumbers?: number[] | undefined;
    fileData?: string[] | undefined;
  }

  export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;
    protected isApiException = true;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
      super();

      this.message = message;
      this.status = status;
      this.response = response;
      this.headers = headers;
      this.result = result;
    }

    static isApiException(obj: any): obj is ApiException {
      return obj.isApiException === true;
    }
  }

  function throwException(message: string, status: number, response: string, headers: {
    [key: string]: any;
  }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
      return _observableThrow(result);
    else
      return _observableThrow(new ApiException(message, status, response, headers, null));
  }

  function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
      if (!blob) {
        observer.next("");
        observer.complete();
      } else {
        let reader = new FileReader();
        reader.onload = event => {
          observer.next((event.target as any).result);
          observer.complete();
        };
        reader.readAsText(blob);
      }
    });
  }

}
